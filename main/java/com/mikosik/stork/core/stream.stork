
  build {
    module
      (exportAs("stork.stream.some")("some"))
      (exportAs("stork.stream.none")("none"))
      (exportAs("stork.stream.reduce")("reduce"))
      (exportAs("stork.stream.tryAt")("tryAt"))
      (exportAs("stork.stream.length")("length"))
      (exportAs("stork.stream.single")("single"))
      (exportAs("stork.stream.repeat")("repeat"))
      (exportAs("stork.stream.tryFirst")("tryFirst"))
      (exportAs("stork.stream.skip")("skip"))
      (exportAs("stork.stream.filter")("filter"))
      (exportAs("stork.stream.while")("while"))
      (exportAs("stork.stream.contains")("contains"))
      (exportAs("stork.stream.tryFind")("tryFind"))
      (exportAs("stork.stream.each")("each"))
      (exportAs("stork.stream.reverse")("reverse"))
      (exportAs("stork.stream.append")("append"))
      (exportAs("stork.stream.prepend")("prepend"))
      (exportAs("stork.stream.flatten")("flatten"))
      (exportAs("stork.stream.array")("array"))
      (exportAs("stork.stream.generate")("generate"))
      (exportAs("stork.stream.for")("for"))
      (exportAs("stork.stream.count")("count"))
      (exportAs("stork.stream.countFrom")("countFrom"))

      (exportAs("private.stork.stream.array2")("array2"))
      (exportAs("private.stork.stream.array3")("array3"))

      (importAs("present")("stork.optional.present"))
      (importAs("absent")("stork.optional.absent"))
      (importAs("add")("stork.integer.add"))
      (importAs("moreThan")("stork.integer.moreThan"))
      (importAs("increment")("stork.integer.increment"))
      (importAs("decrement")("stork.integer.decrement"))
      (importAs("flip")("stork.function.flip"))
      (importAs("false")("stork.boolean.false"))
      (importAs("or")("stork.boolean.or"))
  }

  some(head)(tail)(vSome)(vNone) {
    vSome(head)(tail)
  }

  none(vSome)(vNone) {
    vNone
  }



  reduce(sum)(add)(stream) {
    stream
      ((head)(tail) {
        reduce
          (add(head)(sum))
          (add)
          (tail)
      })
      (sum)
  }

  tryAt(index)(stream) {
    tryFirst(skip(index)(stream))
  }

  length(stream) {
    stream
      ((head)(tail){ add(1)(length(tail)) })
      (0)
  }

  single(element) {
    some(element)(none)
  }

  repeat(element) {
    some
      (element)
      (repeat(element))
  }

  tryFirst(stream) {
    stream
      ((head)(tail){ present(head) })
      (absent)
  }

  limit(n)(stream) {
    moreThan(0)(n)
      (stream
        ((head)(tail) {
          some(head)(limit(decrement(n))(tail))
        })
        (none)
      )
      (none)
  }

  skip(n)(stream) {
    moreThan(0)(n)
      (stream
        ((head)(tail) {
          skip(decrement(n))(tail)
        })
        (none)
      )
      (stream)
  }

  filter(condition)(stream) {
    stream
      ((head)(tail) {
        condition(head)
          (some(head)(filter(condition)(tail)))
          (filter(condition)(tail))
      })
      (none)
  }

  while(condition)(stream) {
    stream
      ((head)(tail) {
        condition(head)
          (some(head)(while(condition)(tail)))
          (none)
      })
      (none)
  }

  contains(condition)(stream){
    stream
      ((head)(tail) {
        or
          (condition(head))
          (contains(condition)(tail))
      })
      (false)
  }

  tryFind(condition)(stream) {
    tryFirst(filter(condition)(stream))
  }

  each(transform)(stream) {
    stream
      ((head)(tail) {
        some
          (transform(head))
          (each(transform)(tail))
      })
      (none)
  }

  reverse {
    reduce(none)(some)
  }

  append(end)(stream) {
    stream
      ((head)(tail) {
        some(head)(append(end)(tail))
      })
      (end)
  }

  prepend {
    flip(append)
  }

  flatten {
    reduce(none)(append)
  }

  array(size) {
    array2(size)(none)
  }

  array2(size)(collected) {
    moreThan(0)(size)
      (array3(size)(collected))
      (reverse(collected))
  }

  array3(size)(collected)(element) {
    array2
      (decrement(size))
      (some(element)(collected))
  }

  generate(next)(current) {
    some
      (current)
      (generate(next)(next(current)))
  }

  for(initial)(condition)(next) {
    while(condition)(generate(next)(initial))
  }

  count {
    countFrom(0)
  }

  countFrom {
    generate(increment)
  }
